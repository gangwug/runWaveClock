#################################################################
####Original code written by Dr. Ron Anafi (https://www.med.upenn.edu/apps/faculty/index.php/g275/p8198976)
####Use this modified code to analyze output files from Synergy2
#################################################################
######User set parameters
##change here: raw text datafile from Neo2[Synergy2]
datadirectory=getwd()
##change here: output file from waveclock								                        
outputfilename="demo_output.csv"
##change here if necessary: set the range of periods (e.g. a broad range of circadian period length range from 16h to 36h)
permin=16 #Min acceptable period - periods generated by waveclock less than this are ignored
permax=36 #Max acceptable period - periods generated by waveclock greater than this are ignored

#################################################################
######read the raw data txt file and prepare the dataframe and mask the below chunk of reading the pre-organized csv file
##change here:input data file
datafilename = "demo.txt"

##the below part may need modification depending on the input txt file
dataLines = readLines(datafilename, encoding = "latin1")
##get the index of header line
header_index = grep("^Time\t\\S+\\s+Lum", dataLines)
header_name = unlist( strsplit(dataLines[header_index], "\t") )
##get the index of measurement lines (hour:minute:second)
measure_index = grep("^\\d+:\\d+:\\d+", dataLines)
##prepare the dataframe to run waveclock
dataL = lapply(dataLines[measure_index], function(z){as.data.frame( strsplit(z, "\t") )} )
dataD = t( do.call(cbind, dataL) )
##exclude the time and temperature column
data = apply(dataD[,-(1:2)], 2, as.numeric)
colnames(data) = header_name[-(1:2)]
##get the time points and transfer to the day unit
timepoints = dataD[,1]
timepoints = lapply(timepoints, function(z) {
						zv = as.numeric(unlist(strsplit(z, ":")))
						zout = (zv[1] + zv[2]/60 + zv[3]/3600)/24
						return(round(zout, 4))
                                             })
rownames(data) = timepoints
data = as.data.frame(data)
#################################################################
######read the pre-organized csv file and mask the above chunk of reading the raw data txt file
##change here:input data file (the first column is time point with 'day' as time unit; other columns are measured values)
#datafilename = "demo_preOrganized.csv"

#data = read.csv(datafilename)
#rownames(data) = data[,1]
#data = data[,-1]

#################################################################
######common part
library(waveclock)
dir.create("DataPlots")
dir.create("WavePlots")

###need to re-write here latter; do a check on the time interval, which needs to be evenly sampled, required by waveclock
timelist <- as.numeric(row.names(data))
hourlist <- 24*timelist
deltatime <- (hourlist[2]-hourlist[1])
##Plot the raw data
for(i in 1:dim(data)[2]){
	filename=paste("graph_",names(data)[i],".jpeg",sep="")
	jpeg(file=paste(datadirectory, "DataPlots", filename, sep = "/") )
    plot(as.numeric(row.names(data)), data[,i], type="o", col="blue", ylim=c((0.9*min(data)),( 1.1* max(data))), xlab="time(days)", ylab="counts/sec")
   dev.off()
}
###############################
##Define a table to dunk the output into
output = matrix(NA,nr=dim(data)[2],nc=7)
colnames( output ) <- c(
    "median (midpoint)",
    "median (lower limit)",
    "median (upper limit)",
    "mean (midpoint)",
    "mean (lower limit)",
    "mean (upper limit)",
    "mean")
row.names(output)<-names(data) 
##Iterate through a data file
for(i in 1:dim(data)[2]){
	sd=1
	loop_flag=TRUE
	set.seed(1)
	while ((loop_flag ==TRUE) & (sd<50)){
		filename=paste("waveplot_num",i,".jpeg",sep="")
		jpeg( file=paste(datadirectory, "WavePlots", filename, sep = "/") )
		sd=sd+1
		local_timeseries <- ts(data[,i],start=0, deltat = deltatime )
		local_results <- waveclock(local_timeseries,cfamily.args = list( ptile = 0.005, bstep = 5, nbchain = 5000 ))
		row <- which(local_results$modes$index =="Total") 
		period <- local_results$modes$"median (midpoint)"[row]
		if (length(period)!=0) {loop_flag=FALSE}
		dev.off()
		}	
 	if( !is.null( local_results$modes ) ){
 		output[i,] = unlist( local_results$modes[1,2:8] )}
}
##do consinor regression analysis to get the amplitude (need to modify this part in the future)
amplist<-c()
meanlist<-c()
perlist<-c()
for(i in 1:dim(data)[2]){
	local_dependant <- data[,i]					                   #kinetic series to fit
	local_independant <- hourlist				                   #the factor included because the time in the data file is in days, and period is given in hours
	maxtime=max(local_independant)
  	local_period=output[i,1]  					                   #wavelet determined period

	if(is.na(local_period)|((local_period<permin)|(local_period>permax))){					   # if no determined period or period outside range
		local_period=NA																	       # set period as not determined
		keep_times <- which((local_independant>24) & (local_independant< (maxtime-24)))  	   # stil exclude 1st and last day of date
		local_amp=NA																		   # if no fit period no amp is calculate	
		local_mean=mean(local_dependant[keep_times])										   # baseline is just mean of included data
		}
	else{																									  # if period acceptabe
		keep_times <- which((local_independant>local_period) & (local_independant< (maxtime-local_period)))   # exclude first and last cycle
		local_independant <- local_independant[keep_times]
		local_dependant <- local_dependant[keep_times]	
		sindep <- sin(2*pi*(local_independant/local_period))
		cosdep <- cos(2*pi*(local_independant/local_period))
		fitmodel=lm(local_dependant ~ cosdep + sindep )														#fit to cosinor model
		local_mean=as.vector(fitmodel$coefficients[1])
		cos_coef=as.vector(fitmodel$coefficients[2])
		sin_coef=as.vector(fitmodel$coefficients[3])
		local_amp=(cos_coef^2+sin_coef^2)^(1/2)
		}
	amplist <- append(amplist,local_amp)
	meanlist <- append(meanlist,local_mean)
	perlist <- append(perlist,local_period)
}
outputframe=data.frame(output)
outputframe$Amp <- as.vector(amplist)
outputframe$Baseline <- as.vector(meanlist)
outputframe$Period <- as.vector(perlist)
write.csv(outputframe,outputfilename)
